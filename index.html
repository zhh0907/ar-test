<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // ===== 配置你的 GLB 文件路径 =====
const MODEL_URL = "./lp_robot.glb";
// 模型“前向”轴:大多数 GLB 是 -Z;若你的模型是 +Z,改为 +1
const MODEL_FORWARD_SIGN = -1; // -1: -Z 前向(常见);+1: +Z 前向
// 控制器 pointer 的“前向”轴:很多设备 pointer.Z 指向“背后”,因此默认 -1;如发现反了改 +1
const CONTROLLER_FORWARD_SIGN = -1;

// 移动时的朝向插值速度(弧度/秒)
const ROT_LERP_SPEED = 10.0;

var createScene = async function () {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

  // --- Camera & Light ---
  const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -6), scene);
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);
  const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0,1,0), scene);
  light.intensity = 0.9;

  // --- Ground:线可见、底几乎透明 ---
  const ground = BABYLON.MeshBuilder.CreateGround("myGround", { width: 30, height: 30 }, scene);
  ground.position.y = 0;
  ground.isPickable = true;

  const gridMat = new BABYLON.GridMaterial("gridMat", scene);
  gridMat.gridRatio = 1.0;
  gridMat.majorUnitFrequency = 4;
  gridMat.minorUnitVisibility = 0.9;
  gridMat.lineColor = new BABYLON.Color3(1.0, 1.0, 1.0);
  gridMat.mainColor = new BABYLON.Color3(0, 0, 0);
  gridMat.opacity = 0.03;
  gridMat.alpha = gridMat.opacity;
  gridMat.disableLighting = true;
  gridMat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
  gridMat.backFaceCulling = false;
  gridMat.zOffset = -1;
  ground.material = gridMat;

  // --- Highlight ---
  const hl = new BABYLON.HighlightLayer("hl", scene);
  hl.innerGlow = false; hl.outerGlow = true;
  hl.blurHorizontalSize = 1.0; hl.blurVerticalSize = 1.0;
  const HLCOLOR = new BABYLON.Color3(1.0, 0.85, 0.3);

  // --- 预载 GLB ---
  const glbContainer = await BABYLON.SceneLoader.LoadAssetContainerAsync("", MODEL_URL, scene);
  glbContainer.removeAllFromScene();

  // --- XR:AR 优先,VR 回退,禁用内置移动/传送 ---
  let xr;
  try {
    const supportsAR = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar");
    if (!supportsAR) throw new Error("no AR");
    xr = await scene.createDefaultXRExperienceAsync({
      sessionMode: "immersive-ar",
      referenceSpaceType: "local-floor",
      uiOptions: { sessionMode: "immersive-ar" },
      optionalFeatures: true
    });
    xr.baseExperience.featuresManager.enableFeature(
      BABYLON.WebXRBackgroundRemover.Name, "latest",
      { environmentHelperRemoval: true, skyBoxRemoval: true }
    );
    const fm = xr.baseExperience.featuresManager;
    try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); } catch {}
    try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION); } catch {}
  } catch {
    xr = await scene.createDefaultXRExperienceAsync({
      sessionMode: "immersive-vr",
      referenceSpaceType: "local-floor",
      uiOptions: { sessionMode: "immersive-vr" }
    });
    scene.createDefaultEnvironment({ createGround:false, createSkybox:true, enableGroundShadow:true });
    scene.clearColor = new BABYLON.Color4(0,0,0,1);
    const fm = xr.baseExperience.featuresManager;
    try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); } catch {}
    try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION); } catch {}
  }

  // ====== 状态 ======
  let rightCtrl = null, leftCtrl = null;
  let hoveredRoot = null, lockedRoot = null;

  let stickX = 0, stickY = 0;         // 注意:我们会把 Y 取反,保证“推前 = 前进”
  let lastClickAt = 0;
  const CLICK_DEBOUNCE_MS = 250;

  const DEADZONE_IN  = 0.15;
  const DEADZONE_OUT = 0.10;
  let   inputActive  = false;

  const MAX_SPEED = 2.2;
  const ACCEL_ON  = 14.0;
  const ACCEL_OFF = 4.0;
  const DIR_LERP  = 12.0;
  let   curSpeed  = 0.0;
  let   moveDir   = new BABYLON.Vector3(0,0,0);

  let rightTriggerDown = false;
  let lastSpawnAt = 0;
  const MIN_INTERVAL = 150;

  // ====== 工具 ======
  function rayFromController(ctrl, length = 100) {
    const origin = ctrl.pointer.position.clone();
    const fwd = BABYLON.Vector3.TransformNormal(BABYLON.Axis.Z, ctrl.pointer.getWorldMatrix())
                .scaleInPlace(CONTROLLER_FORWARD_SIGN)
                .normalize();
    return new BABYLON.Ray(origin, fwd, length);
  }

  function getWorldMinMaxY(root) {
    let minY = +Infinity, maxY = -Infinity;
    root.getChildMeshes().forEach((m) => {
      const bb = m.getBoundingInfo().boundingBox;
      const vmin = bb.minimumWorld, vmax = bb.maximumWorld;
      if (vmin.y < minY) minY = vmin.y;
      if (vmax.y > maxY) maxY = vmax.y;
    });
    return { minY, maxY };
  }

  function placeRootOnGround(root, groundY) {
    const { minY } = getWorldMinMaxY(root);
    const delta = groundY - minY;
    root.position.y += delta;
    root.metadata.bottomOffset = (root.position.y - minY);
  }

  function setRootHighlight(root, on) {
    const meshes = root.getChildMeshes();
    if (on) meshes.forEach(m => hl.addMesh(m, HLCOLOR));
    else    meshes.forEach(m => hl.removeMesh(m));
  }

  function instantiateModel(name, scene) {
    const inst = glbContainer.instantiateModelsToScene((src) => `${name}_${src}`, false);
    const root = new BABYLON.TransformNode(`${name}_root`, scene);
    inst.rootNodes.forEach((n) => { n.parent = root; });

    root.getChildMeshes().forEach((m) => {
      m.isPickable = true;
      m.metadata = m.metadata || {};
      m.metadata.spawnedRoot = root;
    });

    root.metadata = root.metadata || {};
    root.metadata.isSpawnedModel = true;
    root.metadata.inst = inst;
    root.metadata.bottomOffset = 0;
    root.metadata.animPlaying = false;
    return root;
  }

  function clipPick(groups, ks) {
    const kw = ks.map(k => k.toLowerCase());
    const out = groups.filter(g => kw.some(k => g.name.toLowerCase().includes(k)));
    return out.length ? out : null;
  }
  function stopToStatic(root) {
    const inst = root?.metadata?.inst; if (!inst) return;
    const groups = inst.animationGroups || [];
    groups.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });
    const idle = clipPick(groups, ["idle"]);
    if (idle) idle.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });
    else if (groups[0]) { groups[0].stop(); groups[0].reset(); groups[0].goToFrame(groups[0].from); }
    root.metadata.animPlaying = false;
  }
  function playMovingLoop(root) {
    const inst = root?.metadata?.inst; if (!inst) return;
    const groups = inst.animationGroups || []; if (!groups.length) return;
    groups.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });
    let playList = clipPick(groups, ["walk","move","run"]);
    if (!playList) playList = clipPick(groups, ["idle"]);
    if (!playList) playList = groups;
    playList.forEach(ag => ag.start(true, 1.0, ag.from, ag.to));
    root.metadata.animPlaying = true;
  }

  function faceUserYaw(root) {
    const cam = (xr && xr.baseExperience && xr.baseExperience.camera) || scene.activeCamera;
    if (!cam) return;
    const dir = cam.globalPosition.subtract(root.position);
    let yaw = Math.atan2(dir.x, dir.z);
    if (MODEL_FORWARD_SIGN === +1) yaw += Math.PI;
    root.rotationQuaternion = null;
    root.rotation.y = yaw;
  }

  function angleDelta(a, b) {
    let d = a - b;
    while (d >  Math.PI) d -= Math.PI * 2;
    while (d < -Math.PI) d += Math.PI * 2;
    return d;
  }
  function faceDirYaw(root, dir, dt) {
    if (!root || dir.lengthSquared() < 1e-6) return;
    // 目标 yaw 取决于“希望面向的世界方向”
    const yawTarget = (MODEL_FORWARD_SIGN === +1)
      ? Math.atan2(dir.x, dir.z) + Math.PI
      : Math.atan2(dir.x, dir.z);
    root.rotationQuaternion = null;
    const yawNow = root.rotation.y || 0;
    const maxStep = ROT_LERP_SPEED * dt;
    const d = angleDelta(yawTarget, yawNow);
    root.rotation.y = Math.abs(d) <= maxStep ? yawTarget : yawNow + Math.sign(d) * maxStep;
  }

  function spawnModelAt(point) {
    const root = instantiateModel("spawnedModel", scene);
    root.position.copyFrom(point);
    faceUserYaw(root);
    placeRootOnGround(root, ground.position.y);
    stopToStatic(root);

    root.scaling.set(0.01,0.01,0.01);
    BABYLON.Animation.CreateAndStartAnimation(
      "popIn", root, "scaling", 60, 10,
      new BABYLON.Vector3(0.01,0.01,0.01), new BABYLON.Vector3(1,1,1),
      BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
    );
    return root;
  }

  const tmpR = new BABYLON.Vector3(), tmpF = new BABYLON.Vector3();
  function horizontalBasis(ctrl) {
    const m = ctrl.pointer.getWorldMatrix();
    tmpR.copyFrom(BABYLON.Vector3.TransformNormal(BABYLON.Axis.X, m));
    tmpF.copyFrom(BABYLON.Vector3.TransformNormal(BABYLON.Axis.Z, m)).scaleInPlace(CONTROLLER_FORWARD_SIGN);
    tmpR.y = 0; tmpF.y = 0;
    if (tmpR.lengthSquared() < 1e-6) tmpR.copyFrom(BABYLON.Axis.X);
    if (tmpF.lengthSquared() < 1e-6) tmpF.copyFrom(BABYLON.Axis.Z);
    tmpR.normalize(); tmpF.normalize();
    return { right: tmpR, fwd: tmpF };
  }

  // ====== 控制器事件 ======
  xr.input.onControllerAddedObservable.add((controller) => {
    controller.onMotionControllerInitObservable.add((mc) => {
      const hand = mc.handness;
      if (hand === "right") rightCtrl = controller;
      if (hand === "left")  leftCtrl  = controller;

      if (hand === "right") {
        // 右扳机:在 ground 上生成 GLB
        const trigger = mc.getComponent("xr-standard-trigger");
        if (trigger) {
          trigger.onButtonStateChangedObservable.add(() => {
            const pressed = !!trigger.pressed;
            if (pressed && !rightTriggerDown) {
              rightTriggerDown = true;
              const now = performance.now();
              if (now - lastSpawnAt > MIN_INTERVAL && rightCtrl) {
                lastSpawnAt = now;
                const ray = rayFromController(rightCtrl);
                const hit = scene.pickWithRay(ray, (m) => m === ground);
                if (hit?.hit) spawnModelAt(hit.pickedPoint);
              }
            } else if (!pressed && rightTriggerDown) {
              rightTriggerDown = false;
            }
          });
        }

        // 右摇杆:一次点击 = 未锁定→锁定并开动;已锁定→停并解锁
        const stick = mc.getComponent("xr-standard-thumbstick");
        if (stick) {
          stick.onAxisValueChangedObservable.add((axes) => {
            // ★ 把 Y 取反:推前(原本负) → 正值,便于“前进为正”
            stickX = axes.x || 0;
            stickY = -(axes.y || 0);
          });

          let lastPressed = false;
          stick.onButtonStateChangedObservable.add(() => {
            const pressed = !!stick.pressed;

            if (pressed && !lastPressed) {
              const now = performance.now();
              if (now - lastClickAt >= CLICK_DEBOUNCE_MS) {
                lastClickAt = now;

                if (!lockedRoot) {
                  if (hoveredRoot) {
                    lockCurrentHovered();
                    playMovingLoop(lockedRoot);
                  }
                } else {
                  // 停动画并解锁,同时清零移动
                  stopToStatic(lockedRoot);
                  unlockCurrent();
                  stickX = 0; stickY = 0;
                  inputActive = false;
                  curSpeed = 0;
                  moveDir.set(0,0,0);
                }
              }
            }
            lastPressed = pressed;
          });
        }
      }
    });
  });

  xr.input.onControllerRemovedObservable.add((controller) => {
    if (controller === rightCtrl) { rightCtrl = null; stickX = stickY = 0; }
    if (controller === leftCtrl)  { leftCtrl  = null; }
    setHoveredRoot(null);
    unlockCurrent();
  });

  // ====== 帧更新 ======
  scene.onBeforeRenderObservable.add(() => {
    const dt = scene.getEngine().getDeltaTime() / 1000;

    // 悬停(未锁定)
    if (!lockedRoot && rightCtrl) {
      const ray = rayFromController(rightCtrl);
      const pick = scene.pickWithRay(ray, (m) => !!m.metadata?.spawnedRoot);
      const root = pick?.hit ? pick.pickedMesh.metadata.spawnedRoot : null;
      setHoveredRoot(root);
    }

    // 锁定:摇杆控制移动;朝向 = 目标方向(而非位移方向)
    if (lockedRoot && rightCtrl) {
      const mag = Math.hypot(stickX, stickY);
      if (!inputActive) { if (mag > DEADZONE_IN) inputActive = true; }
      else              { if (mag < DEADZONE_OUT) inputActive = false; }

      const { right: R, fwd: F } = horizontalBasis(rightCtrl);

      // 目标方向:直接由摇杆决定(不等速度平滑)
      let targetDir = new BABYLON.Vector3(0,0,0);
      if (inputActive) {
        targetDir.copyFrom(R).scaleInPlace(stickX).addInPlace(F.scale(stickY));
        targetDir.y = 0;
        if (targetDir.lengthSquared() > 1e-6) targetDir.normalize();
      }

      // ★ 只要有输入,就立刻按“目标方向”平滑朝向
      if (inputActive && targetDir.lengthSquared() > 1e-6) {
        faceDirYaw(lockedRoot, targetDir, dt);
      }

      // 位移方向/速度仍然使用平滑的 moveDir / curSpeed
      let targetSpeed = 0;
      if (inputActive && targetDir.lengthSquared() > 1e-6) {
        // 方向平滑
        const a = Math.min(1, DIR_LERP * dt);
        moveDir.x += (targetDir.x - moveDir.x) * a;
        moveDir.z += (targetDir.z - moveDir.z) * a;
        if (moveDir.lengthSquared() > 1e-6) moveDir.normalize();

        targetSpeed = MAX_SPEED * Math.min(1, mag);
      }

      // 速度平滑
      const accel = inputActive ? ACCEL_ON : ACCEL_OFF;
      curSpeed += (targetSpeed - curSpeed) * Math.min(1, accel * dt);

      // 位置更新 + 贴地
      if (curSpeed > 1e-4 && moveDir.lengthSquared() > 1e-6) {
        const delta = moveDir.scale(curSpeed * dt);
        const newPos = lockedRoot.position.add(delta);
        const bottomOffset = lockedRoot.metadata.bottomOffset ?? 0;
        newPos.y = ground.position.y + bottomOffset;
        lockedRoot.position.copyFrom(newPos);
      }
    }
  });

  return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
