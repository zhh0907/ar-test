<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = async function () {
  const scene = new BABYLON.Scene(engine);

  // --- Camera & Light(桌面测试用的自由相机) ---
  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 1.6, -3), scene);
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);

  const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
  light.intensity = 0.8;

  // --- 环境(用于PC测试;进入AR时隐藏) ---
  const env = scene.createDefaultEnvironment({
    enableGroundShadow: false,
    createSkybox: true,
    createGround: true,
    groundSize: 20
  });
  if (env && env.ground) {
    env.ground.isPickable = true;
    env.ground.position.y = 0;
  }

  // --- 准星(命中结果可视化) ---
  const reticle = BABYLON.MeshBuilder.CreateTorus("reticle", {
    diameter: 0.12,
    thickness: 0.006,
    tessellation: 48
  }, scene);
  reticle.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(Math.PI / 2, 0, 0);
  const retMat = new BABYLON.StandardMaterial("retMat", scene);
  retMat.emissiveColor = new BABYLON.Color3(0.1, 0.9, 0.9);
  retMat.disableLighting = true;
  reticle.material = retMat;
  reticle.isPickable = false;
  reticle.setEnabled(false);

  // --- 生成蓝色 Box 的工具函数(带锚点限流) ---
  let spawnCount = 0;
  const MAX_SPAWNS = 30;

  async function spawnBoxAt(position, rotationQuaternion, anchorSystem) {
    if (spawnCount >= MAX_SPAWNS) return;

    const box = BABYLON.MeshBuilder.CreateBox("spawnBox", { size: 0.15 }, scene);
    const mat = new BABYLON.StandardMaterial("boxMat", scene);
    mat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.95);
    mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    box.material = mat;

    try {
      if (anchorSystem && anchorSystem.isEnabled) {
        const anchor = await anchorSystem.addAnchorAtPositionAndRotation(
          position,
          rotationQuaternion || BABYLON.Quaternion.Identity()
        );
        if (anchor && anchor.attachedNode) {
          box.setParent(anchor.attachedNode);
        } else {
          box.position.copyFrom(position);
          if (rotationQuaternion) box.rotationQuaternion = rotationQuaternion.clone();
        }
      } else {
        box.position.copyFrom(position);
        if (rotationQuaternion) box.rotationQuaternion = rotationQuaternion.clone();
      }
      spawnCount++;
    } catch (e) {
      // Anchor 失败则直接放置
      box.position.copyFrom(position);
      if (rotationQuaternion) box.rotationQuaternion = rotationQuaternion.clone();
      spawnCount++;
    }
  }

  // =========================================================
  // =============== WebXR: AR + Hit Test ====================
  // =========================================================
  const xr = await scene.createDefaultXRExperienceAsync({
    disableDefaultUI: false,
    // 更兼容的参考空间:"local"(需要地板高度时再换回 "local-floor" 做对比)
    uiOptions: { sessionMode: "immersive-ar", referenceSpaceType: "local" },
    optionalFeatures: true
  });

  // 进入/退出 XR 时隐藏/显示环境(AR 背景是现实世界)
  xr.baseExperience.onStateChangedObservable.add(state => {
    const inXR = (state === BABYLON.WebXRState.IN_XR || state === BABYLON.WebXRState.ENTERING_XR);
    if (env && env.ground) env.ground.isVisible = !inXR;
    if (env && env.skybox) env.skybox.isVisible = !inXR;
  });

  // 启用 Hit Test(使用 viewer ray,避免对 plane 的依赖带来设备兼容问题)
  const fm = xr.baseExperience.featuresManager;

  let hitTest = null;
  try {
    hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
      // 从视线正前方向外发射射线
      offsetRay: new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, -1), 1.0),
      enableTransientHitTest: true
      // 不指定 entityTypes,优先保证稳定
    });
  } catch (e) {
    console.warn("HIT_TEST feature failed to enable:", e);
  }

  // 可选:Anchor(若不支持会返回 null)
  let anchorSystem = null;
  try {
    anchorSystem = fm.enableFeature(BABYLON.WebXRFeatureName.ANCHOR_SYSTEM, "latest", {});
  } catch (e) {
    console.warn("ANCHOR_SYSTEM feature failed to enable:", e);
  }

  let lastHitPose = null;

  if (hitTest) {
    hitTest.onHitTestResultObservable.add(results => {
      if (results && results.length > 0) {
        const r = results[0];
        lastHitPose = {
          position: r.position.clone(),
          rotationQuaternion: r.rotationQuaternion ? r.rotationQuaternion.clone() : BABYLON.Quaternion.Identity()
        };
        reticle.setEnabled(true);
        reticle.position.copyFrom(lastHitPose.position);
        reticle.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(Math.PI / 2, 0, 0);
      } else {
        lastHitPose = null;
        reticle.setEnabled(false);
      }
    });
  }

  // 控制器/屏幕点击:一次点击只生成一次(去抖)
  xr.input.onControllerAddedObservable.add(controller => {
    // 触屏 AR & 简易点击:统一使用 onSelectStart(可靠的一次性事件)
    controller.onSelectStartObservable.add(() => {
      if (lastHitPose) {
        spawnBoxAt(lastHitPose.position, lastHitPose.rotationQuaternion, anchorSystem);
      }
    });

    // 真·手柄(如右手扳机)额外做“上升沿”防抖
    controller.onMotionControllerInitObservable.add(mc => {
      // 注意:Babylon 属性名为 handedness(不是 handness)
      if (mc.handedness === "right") {
        // 找到扳机组件(不同设备 id 可能不同)
        const triggerId = mc.getComponentIds().find(id => id.indexOf("trigger") !== -1) || "xr-standard-trigger";
        const trigger = mc.getComponent(triggerId);
        if (!trigger) return;

        let ready = true; // 上升沿门闩
        trigger.onButtonStateChangedObservable.add(c => {
          // 仅在 pressed 从 false->true 且(如有)压值足够时触发一次
          const val = (typeof c.value === "number") ? c.value : 1.0;
          if (c.pressed && ready && val >= 0.9) {
            ready = false;
            if (lastHitPose) {
              spawnBoxAt(lastHitPose.position, lastHitPose.rotationQuaternion, anchorSystem);
            }
          }
          if (!c.pressed) ready = true; // 松开后复位
        });
      }
    });
  });

  // =========================================================
  // =============== PC / 无手柄 测试逻辑 =====================
  // =========================================================
  // 在桌面模式下,用鼠标在地面上移动显示准星;左键点击生成 Box
  const pickGroundAndUpdateReticle = (x, y) => {
    if (!env || !env.ground) return;
    const pick = scene.pick(x, y, mesh => mesh === env.ground);
    if (pick && pick.hit) {
      reticle.setEnabled(true);
      reticle.position.copyFrom(pick.pickedPoint);
      reticle.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(Math.PI / 2, 0, 0);
      lastHitPose = {
        position: pick.pickedPoint.clone(),
        rotationQuaternion: BABYLON.Quaternion.Identity()
      };
    } else {
      if (xr.baseExperience.state !== BABYLON.WebXRState.IN_XR) {
        reticle.setEnabled(false);
        lastHitPose = null;
      }
    }
  };

  scene.onPointerMove = () => {
    // 仅在非 XR(桌面)时用鼠标更新准星
    if (xr.baseExperience.state !== BABYLON.WebXRState.IN_XR) {
      pickGroundAndUpdateReticle(scene.pointerX, scene.pointerY);
    }
  };

  scene.onPointerDown = (evt) => {
    if (xr.baseExperience.state !== BABYLON.WebXRState.IN_XR) {
      // 桌面左键点击生成
      if (evt.button === 0 && lastHitPose) {
        spawnBoxAt(lastHitPose.position, lastHitPose.rotationQuaternion, null /* 桌面无 anchor */);
      }
    }
  };

  // 初始把准星藏起来,等有命中或鼠标移到地面时再显示
  reticle.setEnabled(false);

  return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
