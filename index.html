<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // ===== 配置你的 GLB 文件路径 =====
const MODEL_URL = "./lp_robot.glb";
// 大多数 GLTF 模型“向前”为 -Z;若你的模型向前是 +Z,把它改成 +1
const MODEL_FORWARD_SIGN = -1; // -1: -Z 前向(常见);+1: +Z 前向

var createScene = async function () {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // AR 透视

  // --- Camera & Light ---
  const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -6), scene);
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);
  const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0,1,0), scene);
  light.intensity = 0.9;

  // --- Ground:只显示网格线,底面完全透明 ---
  const ground = BABYLON.MeshBuilder.CreateGround("myGround", { width: 30, height: 30 }, scene);
  ground.position.y = 0;
  ground.isPickable = true;

  const gridMat = new BABYLON.GridMaterial("gridMat", scene);
  gridMat.gridRatio = 1.0;
  gridMat.majorUnitFrequency = 4;
  gridMat.minorUnitVisibility = 0.9;
  gridMat.lineColor = new BABYLON.Color3(0.95, 1.0, 0.95);
  gridMat.mainColor = new BABYLON.Color3(0, 0, 0);
  gridMat.opacity = 0.0;                   // 背景完全透明
  gridMat.alpha = 0.0;                     // 兼容某些平台
  gridMat.disableLighting = true;
  gridMat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
  gridMat.backFaceCulling = false;
  gridMat.zOffset = -1;
  ground.material = gridMat;

  // --- Highlight(悬停/锁定) ---
  const hl = new BABYLON.HighlightLayer("hl", scene);
  hl.innerGlow = false; hl.outerGlow = true;
  hl.blurHorizontalSize = 1.0; hl.blurVerticalSize = 1.0;
  const HLCOLOR = new BABYLON.Color3(1.0, 0.85, 0.3);

  // --- 预载 GLB ---
  const glbContainer = await BABYLON.SceneLoader.LoadAssetContainerAsync("", MODEL_URL, scene);
  glbContainer.removeAllFromScene();

  // --- XR:AR 优先,VR 回退 & 禁用内置移动/传送 ---
  let xr;
  try {
    const supportsAR = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar");
    if (!supportsAR) throw new Error("no AR");
    xr = await scene.createDefaultXRExperienceAsync({
      sessionMode: "immersive-ar",
      referenceSpaceType: "local-floor",
      uiOptions: { sessionMode: "immersive-ar" },
      optionalFeatures: true
    });
    xr.baseExperience.featuresManager.enableFeature(
      BABYLON.WebXRBackgroundRemover.Name, "latest",
      { environmentHelperRemoval: true, skyBoxRemoval: true }
    );
    const fm = xr.baseExperience.featuresManager;
    try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); } catch {}
    try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION); } catch {}
  } catch {
    xr = await scene.createDefaultXRExperienceAsync({
      sessionMode: "immersive-vr",
      referenceSpaceType: "local-floor",
      uiOptions: { sessionMode: "immersive-vr" }
    });
    scene.createDefaultEnvironment({ createGround:false, createSkybox:true, enableGroundShadow:true });
    scene.clearColor = new BABYLON.Color4(0,0,0,1);
    const fm = xr.baseExperience.featuresManager;
    try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); } catch {}
    try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION); } catch {}
  }

  // ====== 状态 ======
  let rightCtrl = null, leftCtrl = null;
  let hoveredRoot = null, lockedRoot = null;

  let stickX = 0, stickY = 0;
  let stickPressed = false;
  let stickPressDownAt = 0;
  const LONG_PRESS_MS = 450; // 长按用于解锁

  // 连续移动(方向 + 标量速度)
  const DEADZONE_IN  = 0.15;
  const DEADZONE_OUT = 0.10;
  let   inputActive  = false;

  const MAX_SPEED = 2.2;
  const ACCEL_ON  = 14.0;
  const ACCEL_OFF = 4.0;
  const DIR_LERP  = 12.0;
  let   curSpeed  = 0.0;
  let   moveDir   = new BABYLON.Vector3(0,0,0);

  // 生成防抖
  let rightTriggerDown = false;
  let lastSpawnAt = 0;
  const MIN_INTERVAL = 150;

  // ====== 工具 ======
  function rayFromController(ctrl, length = 100) {
    const origin = ctrl.pointer.position.clone();
    const fwd = BABYLON.Vector3.TransformNormal(BABYLON.Axis.Z, ctrl.pointer.getWorldMatrix()).normalize();
    return new BABYLON.Ray(origin, fwd, length);
  }

  function computeHalfY(root) {
    let minY = +Infinity, maxY = -Infinity;
    root.getChildMeshes().forEach((m) => {
      const bb = m.getBoundingInfo().boundingBox;
      const vmin = bb.minimumWorld, vmax = bb.maximumWorld;
      if (vmin.y < minY) minY = vmin.y;
      if (vmax.y > maxY) maxY = vmax.y;
    });
    return Math.max(0, maxY - minY) * 0.5;
  }

  function setRootHighlight(root, on) {
    const meshes = root.getChildMeshes();
    if (on) meshes.forEach(m => hl.addMesh(m, HLCOLOR));
    else    meshes.forEach(m => hl.removeMesh(m));
  }

  function instantiateModel(name, scene) {
    const inst = glbContainer.instantiateModelsToScene((src) => `${name}_${src}`, false);
    const root = new BABYLON.TransformNode(`${name}_root`, scene);
    inst.rootNodes.forEach((n) => { n.parent = root; });

    root.getChildMeshes().forEach((m) => {
      m.isPickable = true;
      m.metadata = m.metadata || {};
      m.metadata.spawnedRoot = root;
    });

    root.metadata = root.metadata || {};
    root.metadata.isSpawnedModel = true;
    root.metadata.inst = inst;
    root.metadata.halfY = 0;
    root.metadata.animPlaying = false; // ★ 动画播放开关(右摇杆短按切换)
    return root;
  }

  // —— 动画控制 —— //
  function clipPick(groups, ks) {
    const kw = ks.map(k => k.toLowerCase());
    const out = groups.filter(g => kw.some(k => g.name.toLowerCase().includes(k)));
    return out.length ? out : null;
  }
  function stopToStatic(root) {
    const inst = root?.metadata?.inst; if (!inst) return;
    const groups = inst.animationGroups || [];
    groups.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });
    const idle = clipPick(groups, ["idle"]);
    if (idle) idle.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });
    else if (groups[0]) { groups[0].stop(); groups[0].reset(); groups[0].goToFrame(groups[0].from); }
    root.metadata.animPlaying = false;
  }
  function playMovingLoop(root) {
    const inst = root?.metadata?.inst; if (!inst) return;
    const groups = inst.animationGroups || []; if (!groups.length) return;

    // 每次切换前先干净复位,避免叠加
    groups.forEach(ag => { ag.stop(); ag.reset(); ag.goToFrame(ag.from); });

    let playList = clipPick(groups, ["walk","move","run"]);
    if (!playList) playList = clipPick(groups, ["idle"]);
    if (!playList) playList = groups;

    playList.forEach(ag => ag.start(true, 1.0, ag.from, ag.to));
    root.metadata.animPlaying = true;
  }

  // —— 让模型“正对用户” ——
  function faceUserYaw(root) {
    const cam = (xr && xr.baseExperience && xr.baseExperience.camera) || scene.activeCamera;
    if (!cam) return;
    const dir = cam.globalPosition.subtract(root.position);
    let yaw = Math.atan2(dir.x, dir.z);
    if (MODEL_FORWARD_SIGN === +1) yaw += Math.PI;
    root.rotationQuaternion = null;
    root.rotation.y = yaw;
  }

  function spawnModelAt(point) {
    const root = instantiateModel("spawnedModel", scene);

    // 放置到点并面向用户
    root.position.copyFrom(point);
    faceUserYaw(root);

    // 贴地
    const halfY = computeHalfY(root);
    root.metadata.halfY = halfY;
    root.position.y = ground.position.y + halfY;

    // 生成时静态
    stopToStatic(root);

    // 弹入
    root.scaling.set(0.01,0.01,0.01);
    BABYLON.Animation.CreateAndStartAnimation(
      "popIn", root, "scaling", 60, 10,
      new BABYLON.Vector3(0.01,0.01,0.01), new BABYLON.Vector3(1,1,1),
      BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
    );
    return root;
  }

  // 悬停/锁定
  function setHoveredRoot(rootOrNull) {
    if (lockedRoot) return;
    if (hoveredRoot === rootOrNull) return;
    if (hoveredRoot) setRootHighlight(hoveredRoot, false);
    hoveredRoot = rootOrNull || null;
    if (hoveredRoot) setRootHighlight(hoveredRoot, true);
  }
  function lockCurrentHovered() {
    if (!hoveredRoot) return;
    setRootHighlight(hoveredRoot, false);
    lockedRoot = hoveredRoot;
    hoveredRoot = null;
    setRootHighlight(lockedRoot, true);
    // 锁定后保持当前动画状态(默认静态)
  }
  function unlockCurrent() {
    if (!lockedRoot) return;
    // 解锁不强制停动画,如需停请改成 stopToStatic(lockedRoot);
    setRootHighlight(lockedRoot, false);
    lockedRoot = null;
  }

  // —— 只取控制器 yaw 的水平基向量 —— //
  const tmpR = new BABYLON.Vector3(), tmpF = new BABYLON.Vector3();
  function horizontalBasis(ctrl) {
    const m = ctrl.pointer.getWorldMatrix();
    tmpR.copyFrom(BABYLON.Vector3.TransformNormal(BABYLON.Axis.X, m));
    tmpF.copyFrom(BABYLON.Vector3.TransformNormal(BABYLON.Axis.Z, m)).scaleInPlace(-1);
    tmpR.y = 0; tmpF.y = 0;
    if (tmpR.lengthSquared() < 1e-6) tmpR.copyFrom(BABYLON.Axis.X);
    if (tmpF.lengthSquared() < 1e-6) tmpF.copyFrom(BABYLON.Axis.Z);
    tmpR.normalize(); tmpF.normalize();
    return { right: tmpR, fwd: tmpF };
  }

  // ====== 控制器事件 ======
  xr.input.onControllerAddedObservable.add((controller) => {
    controller.onMotionControllerInitObservable.add((mc) => {
      const hand = mc.handness;
      if (hand === "right") rightCtrl = controller;
      if (hand === "left")  leftCtrl  = controller;

      if (hand === "right") {
        // 右扳机:在 ground 上生成 GLB
        const trigger = mc.getComponent("xr-standard-trigger");
        if (trigger) {
          trigger.onButtonStateChangedObservable.add(() => {
            const pressed = !!trigger.pressed;
            if (pressed && !rightTriggerDown) {
              rightTriggerDown = true;
              const now = performance.now();
              if (now - lastSpawnAt > MIN_INTERVAL && rightCtrl) {
                lastSpawnAt = now;
                const ray = rayFromController(rightCtrl);
                const hit = scene.pickWithRay(ray, (m) => m === ground);
                if (hit?.hit) spawnModelAt(hit.pickedPoint);
              }
            } else if (!pressed && rightTriggerDown) {
              rightTriggerDown = false;
            }
          });
        }

        // 右摇杆:轴 + 点击(短按:锁定/切动画;长按:解锁)
        const stick = mc.getComponent("xr-standard-thumbstick");
        if (stick) {
          stick.onAxisValueChangedObservable.add((axes) => {
            stickX = axes.x || 0;
            stickY = axes.y || 0;
          });
          stick.onButtonStateChangedObservable.add(() => {
            const pressed = !!stick.pressed;
            if (pressed && !stickPressed) {
              // 按下时记录时间
              stickPressed = true;
              stickPressDownAt = performance.now();
            } else if (!pressed && stickPressed) {
              // 松开:判断长短按
              stickPressed = false;
              const dur = performance.now() - stickPressDownAt;
              const isLong = dur >= LONG_PRESS_MS;

              if (isLong) {
                // 长按:解锁
                if (lockedRoot) unlockCurrent();
              } else {
                // 短按:
                if (!lockedRoot) {
                  // 未锁定 -> 锁定当前悬停
                  if (hoveredRoot) lockCurrentHovered();
                } else {
                  // 已锁定 -> 切换动画开/关
                  if (lockedRoot.metadata.animPlaying) {
                    stopToStatic(lockedRoot);
                  } else {
                    playMovingLoop(lockedRoot);
                  }
                }
              }
            }
          });
        }
      }
    });
  });

  xr.input.onControllerRemovedObservable.add((controller) => {
    if (controller === rightCtrl) { rightCtrl = null; stickX = stickY = 0; }
    if (controller === leftCtrl)  { leftCtrl  = null; }
    setHoveredRoot(null);
    unlockCurrent();
  });

  // ====== 帧更新 ======
  scene.onBeforeRenderObservable.add(() => {
    const dt = scene.getEngine().getDeltaTime() / 1000;

    // 悬停(未锁定)
    if (!lockedRoot && rightCtrl) {
      const ray = rayFromController(rightCtrl);
      const pick = scene.pickWithRay(ray, (m) => !!m.metadata?.spawnedRoot);
      const root = pick?.hit ? pick.pickedMesh.metadata.spawnedRoot : null;
      setHoveredRoot(root);
    }

    // 锁定时:右摇杆控制“任意角度”在水平面移动(动画状态不受输入影响)
    if (lockedRoot && rightCtrl) {
      const mag = Math.hypot(stickX, stickY);
      if (!inputActive) { if (mag > DEADZONE_IN) inputActive = true; }
      else              { if (mag < DEADZONE_OUT) inputActive = false; }

      const { right: R, fwd: F } = horizontalBasis(rightCtrl);

      let targetDir = moveDir.clone();
      let targetSpeed = 0;

      if (inputActive) {
        targetDir = R.scale(stickX).addInPlace(F.scale(stickY));
        targetDir.y = 0;
        if (targetDir.lengthSquared() > 1e-6) targetDir.normalize();
        targetSpeed = MAX_SPEED * Math.min(1, mag);
      }

      if (targetDir.lengthSquared() > 1e-6) {
        const a = Math.min(1, DIR_LERP * dt);
        moveDir.x += (targetDir.x - moveDir.x) * a;
        moveDir.z += (targetDir.z - moveDir.z) * a;
        if (moveDir.lengthSquared() > 1e-6) moveDir.normalize();
      }
      const accel = inputActive ? ACCEL_ON : ACCEL_OFF;
      curSpeed += (targetSpeed - curSpeed) * Math.min(1, accel * dt);

      if (curSpeed > 1e-4 && moveDir.lengthSquared() > 1e-6) {
        const delta = moveDir.scale(curSpeed * dt);
        const newPos = lockedRoot.position.add(delta);
        const halfY = lockedRoot.metadata.halfY || computeHalfY(lockedRoot);
        newPos.y = ground.position.y + halfY;
        lockedRoot.position.copyFrom(newPos);
      }
    }
  });

  return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
